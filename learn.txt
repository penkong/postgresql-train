pg and sql :

with client we connect to db
client is peice of software api utility program

-----------------------

challenges :

writing efficient queries to get data
designing strcuture and schema
when to use advanced features
manage db is prod env.

-----------------------


db design process:

what kind of thing we are storing? define class
cities --> table (store collection of records with related meaning)
city --> row

what props does this thing have? define class props
name country population area --> columns == props

what type of data each props have? define type of props
string string number number

-----------------------

CRETE DB :

  keyword    identifier
CREATE TABLE cities (
	COLUMN1 VARCHAR(50),
  COLUMN2 VARCHAR(50),
  COLUMN3 INTEGER,
  COLUMN4 INTEGER
);

keyword: tell db that we want do sth. capital.
identifier: tell db what thing we want act on.

-----------------------

INSERT :

INSERT INTO cities (name, country, population,area)
VALUES ('tokyo', 'japan',385000, 8223),
       ('shanghai', 'china',375000, 8223)

-----------------------

RETRIVE :

SELECT * FROM cities;
SELECT NAME,COUNTRY FROM cities;

-----------------------

CALCULATE PROPS AND COLUMNS :

SELECT name, population/area FROM cities;

can do math here. 
also 
^ exponent 
|/ square root
@ absolute value   
% reminder

-----------------------

STRING OPERATORS AND FUNCTIONS :

|| join two strings
CONCAT() join 2 strings.
LOWER()
LENGTH()
UPPER()


SELECT name || country AS conacted FROM cities;

SELECT name ||', ' || country AS conacted FROM cities;

-----------------------

FILTERING ROWS WITH WHERE :

order of exec.
// third exec it.
SELECT
  name,
  area
// first exec it
FROM
  cities
// second exec it
WHERE
  area > 4000;

------------------------

comparison in where statements :
= , 
> , 
< , 
>=
IN (is the value present in list) ,  
<= , 
<> (not equal) , 
!= (not equal) 
BETWEEN , 
NOT IN (is the value present in list) 


SELECT name, area FROM cities WHERE area = 4223;

more complicated :

SELECT name, area FROM cities WHERE area BETWEEN 3223 AND 8000;
SELECT name, area FROM cities WHERE name IN ('delhi', 'istanbul');
SELECT name, area FROM cities WHERE name IN ('delhi', 'istanbul') AND area > 4000;

-----------------------

UPDATE :

we not fetch data
UPDATE cities SET population=333333 WHERE name='tokyo';

-----------------------

DELETE :

DELETE FROM cities WHERE name='tokyo';

-----------------------

photo sharing app :

what table should we make totally?

common features like auth , comments

what type of resource(features) exist create table for it.

features that indicated relation or owner ship  BETWEEN 2 types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
google it like this
sql schema upvote system
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

one to many / many to one
one to one / many to many


we handle these relation by new notations

Primary key , Foreign key.

Primary : unique identifier for row.

Foreign : identifier for a record in another table .
          its a Primary key of info from another table .

Foreign key sits in table of many 
Foreign key is a Primary key of table one in one to many relation.

many table get pointer to one table with Foreign key .

many side get Foreign key column.

===

CREATE TABLE users (
	id SERIAL,
);

SERIAL create us autogenerate id incremental in postgres
 
===

CREATE table with Foreign key

CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id),
);

===

JOIN :
WE DO MORE BUT FOR NOW .

SELECT url, username FROM photos JOIN users ON users.id = photos.user_id;


===

Data Consistency : actually means the data we saved already make sense.

if want insert photo and user does not exist?
or if dont assign user to photo? use Null


what happen if you try to delete user when a photo still Referncing

ON DELETE RESTRIC       throw error
ON DELETE NO ACTION     throw error
ON DELETE CASCADE       delete photo too!

ON DELETE SET NULL      set the Foreign key NULL
ON DELETE SET DEFAULT   set the Foreign key to predefined value.


CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE
);

===

queries with joins and aggregation :


join : use to produce value by merging, use join most of times.

aggregation : look at many rows and calculate a single value.
  use with word like 'most' 'least' and other 'average' ... .


=== 

join data from tables.

SELECT
  contents,
  username
FROM
  COMMENTS
  JOIN users ON users.id = COMMENTS.user_id;

===

different kind of join :

handle missing data in joins . like with Foreign key null
we use left join (left outer join) it show us null

also check pdf file in parallel


===

join with where :

SELECT contents, url 
FROM COMMENTS 
JOIN photos ON photos.id = COMMENTS.photo_id 
WHERE photos.user_id = COMMENTS.user_id;

===

3 way join :

SELECT
  contents,
  url,
  username
FROM
  COMMENTS
  JOIN photos ON photos.id = COMMENTS.photo_id
  JOIN users ON users.id = comments.user_id
  AND users.id = photos.user_id
WHERE
  photos.user_id = COMMENTS.user_id;

hint : the most passive table use to select on joins.

===

aggregation and grouping :::

grouping : reduce many rows down to fewer rows.
done by GROUP BY 

''''visualizing'''' the result is key to use.

aggregates : reduces many values down to one .
done by using aggregate functions.

===

SELECT user_id FROM COMMENTS GROUP BY user_id;

''db'' make it unique base on value.

it return ''imaginary grouped column''.

===

aggregate functions :

COUNT() : when we use count null value not counted
          count(*) count all rows.
SUM()
AVG()
MIN()
MAX()

must use alone not with normal select or with group by

SELECT SUM(id) FROM COMMENTS;

===

group by and aggregate combine :

SELECT user_id, COUNT(id) FROM COMMENTS GROUP BY user_id 

===

you need visualizing for grouping .

SELECT photo_id ,COUNT(*) FROM COMMENTS GROUP BY photo_id;

===

orders of filters :

FROM
JOIN
WHERE    : filtering some of rows
GROUP BY
HAVING   : filters the set of groups like where do for rows, 
           always come with group by. 


===

HAVING :
 
for filtering groups always with group by;
with having your normally see aggregate functions.

SELECT
  photo_id,
  COUNT(*)
FROM
  COMMENTS
WHERE
  photo_id < 3
GROUP BY
  photo_id
HAVING
  COUNT(*) > 2;


SELECT
-- 2 imaginary columns.
	user_id , COUNT(*)
FROM
  COMMENTS
WHERE
  photo_id < 50
GROUP BY
  user_id
HAVING
  COUNT(*) > 20;

===
--------------------

E-commerce DataSet :

===

Sorting records :

means sort on retrieve info.

SELECT * FROM products ORDER BY price;
SELECT * FROM products ORDER BY price DESC;
SELECT * FROM products ORDER BY name;

sort by 2 criteria or more :
SELECT * FROM products ORDER BY price, weight;

===

you use this for pagination.

Offset : skip some of the records of result set
SELECT * FROM users OFFSET 40;

limit : make sure only take some specific number of results.
SELECT * FROM users LIMIT 20 OFFSET 20 ;

===


Multiple sets of data :

UNION : join the result of two queries and remove duplicate
UNION ALL : does not remove duplicate

INTERSECT : find the rows common in result of two queries.
INTERSECT ALL : does not remove duplicate

EXCEPT : find the rows that are present in first query but not second. 
EXCEPT ALL : does not remove duplicate.

===

Unions :
normally with 2 different sorting criteria

(SELECT * FROM products ORDER BY price DESC LIMIT 4)
UNION
(SELECT * FROM products ORDER BY price/weight DESC LIMIT 4);

union remove duplicate with UNION ALL we see all .

when you can use union that tables have same columns

===

intersection :

(SELECT * FROM products ORDER BY price DESC LIMIT 4)
INTERSECT
(SELECT * FROM products ORDER BY price/weight DESC LIMIT 4);

===

EXCEPT :

(SELECT * FROM products ORDER BY price DESC LIMIT 4)
EXCEPT 
(SELECT * FROM products ORDER BY price/weight DESC LIMIT 4); 

show 3 row from first remove intersection with second query

===

queries and sub queries :
like : list all products that are more expensive than all prod in other
column.

because we dont use 2 query to db we use sub queries

SELECT
  name,
  price
FROM
  products
WHERE
  price > (
    -- it run first.
    SELECT MAX(price) FROM products WHERE department = 'Toys'
  );

we can use a query with sub queries.
we must change type of data come back from inner query

scalar query : single row single column

in select : any subquery in select place must return value.

in from : sub querie must have an alias for result of subquery, 
          just make sure outer query is compatible.
SELECT
  name,
  price_weight_ratio
FROM
  (
    SELECT
      name,
      price / weight AS price_weight_ratio
    FROM
      products
  ) as p;

use case : make grouping stuff in subquery;
SELECT
  AVG(order_count)
FROM
  (
    SELECT
      user_id,
      COUNT(*) AS order_count
    FROM
      orders
    GROUP BY
      user_id
  ) AS p;

in join clause : if result of subquery is compatible with on clause.

in where clause : more useful state here. return must be single column.  


SELECT
  name, department
FROM
  products
WHERE
  department NOT IN (
    SELECT
      department
    FROM
      products
    WHERE
      price < 100
  );

===

new operators in where clause when use subquery:
> ALL
< ALL
>= ALL
<= ALL
= ALL
<> ALL

> SOME or any (its greater than at least one of the values)
< SOME or any
>= SOME or any
<= SOME or any
= SOME or any
<> SOME or any

SELECT
  name, department, price
FROM
  products
WHERE
  price > ALL (
    SELECT
      price 
    FROM
      products
    WHERE
      department='Industrial'
  );


===

correlated subquery :
case : show the most expensive from each department 
means refer to some rows in inner query from outer query
because it is for loop in for loop 

SELECT
  name, department, price
FROM
  products AS p1
WHERE
  p1.price = (
    SELECT
      MAX(price)
    FROM
      products AS p2
    WHERE
      p1.department= p2.department
  );

SELECT
  p1.name, (
    	SELECT COUNT(*)
    	FROM orders AS o1
    	WHERE o1.product_id = p1.id
    ) AS num_orders
FROM
  products AS p1

we also can put subquery immediately after SELECT as long as 
subquery return single value
SELECT
  (SELECT MAX(price) FROM products);

===

selecting distinct value :

DISTINCT : <==> also GROUP BY
always sit with SELECT clause 
means : what unique are there?

SELECT DISTINCT department FROM products;
SELECT COUNT(DISTINCT department) FROM products;


also can use to get unique combination of whole data
SELECT DISTINCT department, name FROM products;

==

GREATEST :

SELECT GREATEST(20,10,300);

SELECT
  name,
  weight,
  GREATEST(30, 2 * weight)
FROM
  products;


===

Least :
SELECT LEAST(20,10,300);

SELECT
  name,
  price,
  GREATEST(400, 0.5 * price)
FROM
  products;

===

CASE : conditional.

SELECT
  name,
  price,
  CASE
  	WHEN price > 600 THEN 'high'
    WHEN price > 300 THEN 'medium'
    ELSE 'cheap'
  END
FROM
  products;

===
-----------------------

PG local :

===

data types :

for id use SERIAL
for number without decimal use integer
for bank,grams and gold ... use numeric
for not exact decimal use double precision

=== 

SQL EDITOR :
can assign type to number like this in pg
select (2.0::INTEGER);

===

decimal :
=
decimal, numeric
accurate
but less efficient for calculate
=
select (1543232.99999::double precision);
real , double precision , float .
these treat with floating point math
inaccurate
but a lot more efficient for calculate

===

VARCHAR , TEXT , CHAR
CHAR(5) for fix LENGTH of characters  (will be terim or will add empty)
VARCHAR store any LENGTH
VARCHAR(5) for fix LENGTH of characters (will be terim but not add empty)
TEXT store any LENGTH

no diffenece any performance.

===

Boolean Types :

TRUE true 'yes' on 1 t y, 
FALSE false 'no' off 0 f n, 
NULL null

===

Date Time :
it will handle any
TIME is without timezone
TIME WITH TIME ZONE 1:23 pm EST or PST UTC
TIMESTAMP WITH TIME ZONE NOV-20-1980 1:23 AM PST => 1980-11-20 02:23:00-7

INTERVAL : duration of time 1 day or 1 D or 1 D 1 M 1 S
we can do numeric operations on interval
can use to add or minus time from TIMESTAMP

===
---------------------

Validation on Database :

===

Row level Validation :
on insert and update
is defined?
is a  value unique in its column?
is a value > < = >= ?

===

NOT NULL constraints;
when table create or
after table create : ALTER TABLE x ALTER COLUMN SET NOT NULL

ALTER TABLE products ALTER column price SET NOT null;
maybe we have already null value.
update products set price = 9999 where price is null;

===

DEFAULT value :

for ex : price INTEGER DEFAULT 9999

case after create :

ALTER TABLE products 
ALTER column price 
SET DEFAULT 999;

===

UNIQUE constraint :
on create : name VARCHAR(5) unique

or 

on created :
ALTER TABLE products ADD UNIQUE (name);

===

to remove existing constraints :

alter table public.products drop constraint products_pkey

Mulit Column unique :

on create : UNIQUE(name, department)

on created :
alter table products add unique (name,department);


===

check value Validation 

on create : price INTEGER CHECK (price > 0)

on created : ALTER TABLE x ADD CHECK (price > 0);


check Multiple columns :
case : like time of delivery must be after creation.

check (created_at < est_delivary)
===

--------------------------------

DataBase strcuture Design Pattern :

Instagram type database 

===

better doc everything, 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
diagraming tools
we can use a schema designer to see relation 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

dbdiagram.io
drawsql.app
sqldbm.com
quickdatabasediagrams.com
ondras.zarovi.cz/sql/demo

===


Like System :
solution 1 :
polymorphic association (Foreign key refer 2 table)
like a like can be a 'post like' or a 'comment like'
it make Foreign key refer to 2 table bad practice.

solution 2 : 
use likes table with post_id and comment_id
and use COALESCE();

solution 3 :

===


COALESCE:

it is func that look at different args its provided
and it return first value is not null
COALESCE(null,5)
COALESCE(10,5)

COALESCE((4)::Boolean::INTEGER, 0)


we want check in likes table only one of post_id or comment_id exist
Add check of :
(
  COALESCE((post_id)::Boolean::INTEGER, 0) 
  + COALESCE((comment_id)::Boolean::INTEGER, 0)
) = 1

===

hint : view is like bring up together a union  
we generally dont store derived data

===

Mention And Caption :


lat REAL
lng REAL
REAL store 6 digit precisely


===


Followers :

===

-----------------------------

Complex Queries :

===


































































































